<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>SDK开发和打包静态库遇到的坑 | CODE &amp; ZEN</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="我是孙凯旋 @skx926&lt;br&gt;一名来自中国的 iOS 开发者&lt;br&gt;写过 Android&lt;br&gt;也会点 Web&lt;br&gt;深知付出更多才能收获更多&lt;br&gt;唯有在技术的道路上勤勤恳恳&lt;br&gt;方得片刻安心">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="SDK开发和打包静态库遇到的坑 | CODE &amp; ZEN">
    <meta name="twitter:description" content="我是孙凯旋 @skx926&lt;br&gt;一名来自中国的 iOS 开发者&lt;br&gt;写过 Android&lt;br&gt;也会点 Web&lt;br&gt;深知付出更多才能收获更多&lt;br&gt;唯有在技术的道路上勤勤恳恳&lt;br&gt;方得片刻安心">

    <meta property="og:type" content="article">
    <meta property="og:title" content="SDK开发和打包静态库遇到的坑 | CODE &amp; ZEN">
    <meta property="og:description" content="我是孙凯旋 @skx926&lt;br&gt;一名来自中国的 iOS 开发者&lt;br&gt;写过 Android&lt;br&gt;也会点 Web&lt;br&gt;深知付出更多才能收获更多&lt;br&gt;唯有在技术的道路上勤勤恳恳&lt;br&gt;方得片刻安心">

    
    <meta name="author" content="Kyle Sun">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.jpg">
    

    
    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    
    
    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="CODE &amp; ZEN" href="/atom.xml">
    

    <link rel="canonical" href="http://skx926.github.io/2019/03/13/sdk-development/"/>

    
    <link rel="author" href="https://plus.google.com/118328736821069549236"/>
    
    <!-- fancybox support -->
    
        <script src="/lib/jquery-3.3.1.min.js"></script>
        <link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">
        <script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>
        <script src="/js/wrapImage.js"></script>
    
</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 CODE &amp; ZEN 的主页"><img src="/images/logo.jpg" width="80" alt="CODE &amp; ZEN logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for CODE &amp; ZEN">CODE &amp; ZEN</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">凯旋的博客</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">我是孙凯旋 @skx926<br>一名来自中国的 iOS 开发者<br>写过 Android<br>也会点 Web<br>深知付出更多才能收获更多<br>唯有在技术的道路上勤勤恳恳<br>方得片刻安心</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">文章</a></li>
            
              <li class="navigation__item"><a href="/archives">归档</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/ikeson" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/skx926" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  
  <li class="navigation__item">
    <a href="https://plus.google.com/118328736821069549236" title="Google+" target="_blank">
      <i class='social fa fa-google-plus-square'></i>
      <span class="label">Google+</span>
    </a>
  </li>


<!-- Facebook -->


<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/skx926" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

<!-- instagram -->

  <li class="navigation__item">
    <a href="https://www.instagram.com/skx926" title="上Instagram找我" target="_blank">
      <i class='social fa fa-instagram'></i>
      <span class="label">Twitter</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-slate"></div>
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-03-13T06:27:34.000Z" class="post-list__meta--date date">2019/03/13</time>
 &#8226; <span class="post-meta__tags tags">分类&nbsp;
  <a class="tag-link" href="/tags/iOS/">iOS</a>

</span>
    </div>
    <h1 class="post-title">SDK开发和打包静态库遇到的坑</h1>
  </header>

  <section class="post">
    <p>我们在使用第三方库的时候一般有三种接入方式：</p>
<ol type="1">
<li>直接把第三方库的源码拖入工程</li>
<li>通过CocoaPods等包管理工具进行引入</li>
<li>通过.a或者.framework静态库引入</li>
</ol>
<p>前两种情况一般是用于引入开源的项目，比如<code>AFNetworking</code>、<code>SDWebImage</code>；第三种情况一般是用于引入一些不方便开源的SDK，比如微信支付的SDK、百度地图的SDK。</p>
<h2 id="sdk开发注意点">SDK开发注意点</h2>
<p>如果我们要做一个静态库形式的SDK，有什么需要注意的呢？</p>
<ol type="1">
<li>没有必要暴露的头文件就不要暴露给外部</li>
<li>类名、分类方法名、全局变量、全局函数、枚举、宏定义要加前缀</li>
<li>SDK中引入的第三方库和接入项目中引入的第三方库冲突问题</li>
</ol>
<p>这里的第三点是我们在SDK开发中需要重点注意的问题：比如说我们SDK中引入了<code>AFNetworking</code>，我们打包的静态库中就会包含AF的所有代码，如果接入我们SDK的项目中也引入了AF，编译的时候就会报<code>duplicate symbols</code>符号重复的错误。</p>
<p>怎么解决这个问题呢？有下面几种方法：</p>
<ul>
<li>改名。顾名思义，改名就是把我们SDK中引入的AF库中的类名、分类方法名、全局变量、全局函数、枚举、宏定义都加上前缀。这个办法有点麻烦，后续如果要升级第三方库就又得改一遍，当然如果写一个脚本来帮我们做这个事情也挺不错。这个方法的好处就是如果接入方项目中和我们SDK中引入的AF的版本不一样时也不会出错。因为他们是完全独立的，不会互相影响。</li>
<li>使用CocoaPods引入第三方库并使用<a href="https://github.com/CocoaPods/CocoaPods-packager" target="_blank" rel="noopener">CocoaPods Packager</a>来打包静态库。CocoaPods Packager在打包静态库的过程中会自动将引入的第三方库的符号加上前缀（Name-Mangling）。如果我们引入的第三方库也是一个静态库，那这个自动改名就无法生效了。</li>
<li>打包的静态库中不要包含第三方库，让接入方去引入。这样就可以保证同一个第三方库只有一份了。但是如果我们SDK中使用的第三方库的和接入方项目中引入的第三方库的版本不同的时候也会有一些问题。需要双方修改成使用统计的版本，要么你改，要么我改。</li>
<li>SDK中不要引入第三方库，自己写一份实现（如果你不差时间、也能写得出来的话）。</li>
</ul>
<p>上面这三种方式各有各的优缺点，总结起来一下就是：如果SDK中引入的第三方库很少或者很简单的话，你可以考虑手动改名字或者自己实现一个；如果SDK中不会引入其他的静态库，使用CocoaPods Packager将会是你不二的选择；如果SDK中引入了静态库，那么在打包静态库的时候就不要把引入的静态库打包进去，直接把两个静态库文件（SDK的静态库和SDK引入的静态库）都提供给接入方使用。</p>
<h2 id="使用cocoapods-packager打包静态库">使用CocoaPods Packager打包静态库</h2>
<p>由于我们初期没有预估到SDK中会引入静态库，所以最先采用了CocoaPods Packager的方式。</p>
<h3 id="创建私有pod库">创建私有pod库</h3>
<p>要使用CocoaPods Packager打包静态库，我们首先得有一个pod库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod lib create <span class="string">'YourPodName'</span></span><br></pre></td></tr></table></figure>
<p>使用上面的命令之后我们就可以创建一个名为<code>YourPodName</code>的本地pod库，你会注意到Pods项目中比平常多了一个Development Pods文件夹，这个文件夹下面的<code>YourPodName</code>文件夹就是我们的库的源文件的存放目录。打开Podfile文件你会看到一行<code>pod 'YourPodName', :path =&gt; '../'</code>，这个path指向的就是我们的pod库的podspec文件的路径，也就是Podfile文件的上一级目录。</p>
<p>打开<code>YourPodName.podspec</code>文件可以看到很多内容，我们逐个来解释一下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span><span class="params">|s|</span></span><br><span class="line">  <span class="comment"># 项目名称</span></span><br><span class="line">  s.name             = <span class="string">'YourPodName'</span></span><br><span class="line">  <span class="comment"># 版本</span></span><br><span class="line">  s.version          = <span class="string">'0.1.0'</span></span><br><span class="line">  <span class="comment"># 简介</span></span><br><span class="line">  s.summary          = <span class="string">'A short description of YourPodName.'</span></span><br><span class="line">  <span class="comment"># 详细介绍</span></span><br><span class="line">  s.description      = <span class="string">"详细介绍"</span></span><br><span class="line">  <span class="comment"># 项目主页</span></span><br><span class="line">  s.homepage         = <span class="string">"https://github.com/skx926/YourPodName"</span></span><br><span class="line">  <span class="comment"># 截图                      </span></span><br><span class="line">  s.screenshots      = <span class="string">"www.example.com/screenshots_1"</span></span><br><span class="line">  <span class="comment"># 支持的协议及文件</span></span><br><span class="line">  s.license          = &#123; <span class="symbol">:type</span> =&gt; <span class="string">'MIT'</span>, <span class="symbol">:file</span> =&gt; <span class="string">'LICENSE'</span> &#125;</span><br><span class="line">  <span class="comment"># 作者名字和邮箱</span></span><br><span class="line">  s.author           = &#123; <span class="string">'skx926'</span> =&gt; <span class="string">'skx926@gmail.com'</span> &#125;</span><br><span class="line">  <span class="comment"># 仓库地址</span></span><br><span class="line">  s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">'https://github.com/skx926/YourPodName.git'</span>, <span class="symbol">:tag</span> =&gt; s.version.to_s &#125;</span><br><span class="line">  <span class="comment"># 社交媒体地址</span></span><br><span class="line">  s.social_media_url = <span class="string">'https://twitter.com/skx926'</span>  </span><br><span class="line">  <span class="comment"># 最低要求的系统版本</span></span><br><span class="line">  s.ios.deployment_target = <span class="string">'8.0'</span></span><br><span class="line">  <span class="comment"># 源文件路径</span></span><br><span class="line">  s.source_files = <span class="string">'YourPodName/Classes/**/*'</span></span><br><span class="line">  <span class="comment"># 资源文件存放位置</span></span><br><span class="line">  s.resource_bundles = &#123;</span><br><span class="line">    <span class="string">'YourPodName'</span> =&gt; [<span class="string">'YourPodName/Assets/*.png'</span>]</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment"># 暴露给外部的头文件</span></span><br><span class="line">  s.public_header_files = <span class="string">'YourPodName/Classes/**/*.h'</span></span><br><span class="line">  <span class="comment"># 项目中使用的系统framework</span></span><br><span class="line">  s.frameworks = <span class="string">'UIKit'</span>, <span class="string">'MapKit'</span></span><br><span class="line">  <span class="comment"># 项目中使用的第三方framework</span></span><br><span class="line">  s.vendored_frameworks = <span class="string">'Thirdparty.framework'</span></span><br><span class="line">  <span class="comment"># 项目中使用的系统静态库</span></span><br><span class="line">  s.libraries = <span class="string">'iconv'</span>, <span class="string">'xml2'</span></span><br><span class="line">  <span class="comment"># 项目中使用的第三方静态库</span></span><br><span class="line">  s.vendored_libraries = <span class="string">'Library/gmssl/*.a'</span></span><br><span class="line">  <span class="comment"># Xcode配置</span></span><br><span class="line">  s.xcconfig = &#123; <span class="string">"HEADER_SEARCH_PATHS"</span> =&gt; <span class="string">"$&#123;PODS_ROOT&#125;/../../Library/gmssl"</span>&#125;</span><br><span class="line">  <span class="comment"># 项目依赖的第三方库</span></span><br><span class="line">  s.dependency <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.3'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>比较麻烦的是我们要往pod库中添加源文件的时候不能只在Xcode中拖进去，如果要正常使用的话，每次添加文件都需要执行<code>pod install</code>命令。</p>
<p>项目中使用的资源文件需要添加到<code>s.resource_bundles</code>里面所设置的路径当中，执行<code>pod install</code>命令之后他们就会出现在Resources文件夹当中。</p>
<p>在项目运行的时候这些资源文件会被打包到<code>YourPodName.bundle</code>当中，这个bundle的名字就是<code>s.resource_bundle</code>中设置的。</p>
<p>由于这些资源被打包在bundle之中，使用的时候也需要有所变化。我们以图片为例：假如我们有一张名为<code>avatar@2x.png</code>的图片放在<code>YourPodName/Assets/images/</code>文件夹下，它在bundle中的路径就是<code>YourPodName.bundle/images/avatar@2x.png</code>，要使用这张图片的话我们首先得拿到这个bundle的实例，为了方便拿到这个实例，我们给NSBundle增加一个分类方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSBundle</span> *)ks_bundle &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSBundle</span> *resourceBundle = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 通过SDK中的一个类来获取SDK所在的Bundle，然后在在这个bundle中寻找存放我们资源文件的bundle</span></span><br><span class="line">        <span class="built_in">NSString</span> *resourceBundlePath = [[<span class="built_in">NSBundle</span> bundleForClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"AnyClassInYourPod"</span>)] pathForResource:<span class="string">@"YourPodName"</span> ofType:<span class="string">@"bundle"</span>];</span><br><span class="line">        resourceBundle = [<span class="keyword">self</span> bundleWithPath:resourceBundlePath];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> resourceBundle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再给UIImage增加一个分类方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)ks_imageNamed:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="comment">// 图片名称需要包含它的路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"images/%@"</span>, name];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:imageName inBundle:<span class="built_in">NSBundle</span>.spy_bundle compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以通过<code>[UIImage ks_imageNamed:@"avatar"]</code>来获取图片了。</p>
<h3 id="安装cocoapods-packager">安装CocoaPods Packager</h3>
<p>CocoaPods Packager是CocoaPods的一个插件，需要单独的命令来安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo gem install cocoapods-packager</span><br></pre></td></tr></table></figure>
<p>安装成功就可以使用<code>pod package YourPodName.podspec</code>命令来打包了，我们来看一下这个命令有哪些参数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 强制覆盖之前生成的文件</span><br><span class="line">--force</span><br><span class="line">// 不使用name-mangling技术，也就是自动改类名等符号</span><br><span class="line">--no-mangle</span><br><span class="line">// 生成静态的framework</span><br><span class="line">--embedded</span><br><span class="line">// 生成静态.a</span><br><span class="line">--library</span><br><span class="line">// 生成动态framework</span><br><span class="line">--dynamic</span><br><span class="line">// 使用本地文件</span><br><span class="line">--local</span><br><span class="line">// 生成动态framework的时候需要这个BundleId来签名</span><br><span class="line">--bundle-identifier</span><br><span class="line">// 不包含依赖的符号表，也就是不把依赖的第三方库打包进去</span><br><span class="line">--exclude-deps</span><br><span class="line">// 生成debug还是release的库，默认是release</span><br><span class="line">--configuration=Release </span><br><span class="line">// 如果你的pod库有subspec，那么加上这个命名表示只给某个或几个subspec生成二进制库</span><br><span class="line">--subspecs=subspec1,subspec2</span><br><span class="line">// 默认是CocoaPods的Specs仓库，如果你的项目依赖使用的是私有的<span class="built_in">source</span>，就可以通过这个参数来设置</span><br><span class="line">--spec-sources=private,https://github.com/CocoaPods/Specs.git</span><br></pre></td></tr></table></figure>
<p>使用下面的命令就可以打包静态库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod package YourPodName.podspec --force --library</span><br></pre></td></tr></table></figure>
<p>打包的流程是这样的：</p>
<ol type="1">
<li>根据podspec里<code>s.source</code>指定的git仓库中克隆tag和<code>s.version</code>相同的版本到本地</li>
<li>执行pod install安装依赖（这些依赖的来源就是<code>--spec-sources</code>参数所指定的）</li>
<li>编译生成目标文件</li>
<li>执行Name-Mangling进行改名</li>
<li>生成最终的静态库文件</li>
</ol>
<p>由于每次打包都是从git仓库上面克隆，所以我们在打包之前必须把本地的代码提交到git仓库并打上相应版本的tag。</p>
<p>这样操作确实挺麻烦，所以有人给CocoaPods Packager提交了一个<a href="https://github.com/CocoaPods/cocoapods-packager/pull/195" target="_blank" rel="noopener">Pull Request:Add --local option to use local sources while packaging #195</a> 来增加一个<code>--library</code>的命令来支持使用本地的环境直接打包，而不是每次都从git上面clone。</p>
<p>作者已经merge了这个pr，但是并没有发布新的版本，所以使用gem更新cocoapods-packager这个插件的话是更新不了的，你可以自己从<a href="https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">GitHub</a>上克隆源码编译安装最新版就支持这个功能了。</p>
<h3 id="name-mangling做了哪些事">Name-Mangling做了哪些事</h3>
<p>到目前为止，如果你的SDK里面没有包含第三方的静态库，那么使用上面的命令就已经很舒服了。你可能会好奇Name-Mangling具体会改哪些东西，我们从CocoaPods Packager源码<a href="https://github.com/CocoaPods/CocoaPods-packager/blob/master/lib/CocoaPods-packager/mangle.rb" target="_blank" rel="noopener">mangle.rb</a>文件中可以窥探一二：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># performs symbol aliasing</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># for each dependency:</span></span><br><span class="line"><span class="comment"># 	- determine symbols for classes and global constants</span></span><br><span class="line"><span class="comment"># 	- alias each symbol to Pod#&#123;pod_name&#125;_#&#123;symbol&#125;</span></span><br><span class="line"><span class="comment"># 	- put defines into `GCC_PREPROCESSOR_DEFINITIONS` for passing to Xcode</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>注释里写的很清楚了，Name-Mangling会把类名和全局常量改成<code>Pod#{pod_name}_#{symbol}</code>的形式，比如说我们的pod库YourPodName中有一个YourClass类，那它最终会被改成<code>PodYourPodName_YourClass</code>。</p>
<p>需要注意的是Name-Mangling并不会改方法名，也就是说如果我们引入的第三方库给系统类比如UIImage增加了分类方法，而恰巧接入方的源码中也引入了这个第三方库，给UIImage增加同样名称的分类方法，由于分类的特性我们可以知道他们不会冲突，而是会产生覆盖，一般来说也不会有问题。</p>
<p>但是如果两边引入的第三方库的版本不同，分类方法的实现也有所不同，那这就可能会产生问题。不过分类的实现一般比较固定，出现这种情况的概率比较小。</p>
<h3 id="sdk中引入静态库">SDK中引入静态库</h3>
<p>我们私有pod库中要引入静态库很简单，只需要在podspec文件中配置好静态库的路径<code>s.vendored_libraries = 'YourLibrayPath/*.a'</code>，并把静态库的头文件加入到源码路径中<code>s.source_files = 'YourPodName/Classes/**/*'</code>，执行<code>pod install</code>就可以正常使用了。</p>
<p>但是如果这个静态库比较复杂，比如说gmssl，他里面包含两个静态库和几十上百个头文件，事情就变得比较棘手了，如下图所示：</p>
<img src="/2019/03/13/sdk-development/gmssl.png">
<p>主要问题在与这些个头文件之间是用尖括号<code>&lt;&gt;</code>以模块的形式引入的，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/e_os2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/opensslconf.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这里就涉及到一个头文件的搜索路径的问题，如果我们直接把这些头文件加入到项目当中去就会报找不到头文件的异常。我们可以手动把他们都改成双引号的形式:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"e_os2.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opensslconf.h"</span></span></span><br></pre></td></tr></table></figure>
<p>这种办法虽然可以解决问题，但是几十个文件改起来也不是件轻松的事情。更简单的办法是在<code>Pods.xcodeproj</code>文件的<code>Build Settings</code>中设置<code>Header Search Paths</code>，让它指向openssl所在的文件夹。<code>Pods.xcodeproj</code>中的设置在每次执行<code>pod install</code>之后都会被重置，这个时候我们上面提到的在podspec文件中设置<code>s.xcconfig = { "HEADER_SEARCH_PATHS" =&gt; "${PODS_ROOT}/../../Library/gmssl"}</code>就排上用场了。</p>
<p>通过这种方式引入的静态库在我们的Demo project下是可以正常运行的，但是一旦用CocoaPods Packager打包还是会报找不到静态库头文件的异常。这个问题我暂时知道的唯一的解决办法就是上面提到的直接把头文件中的互相引用改成双引号的形式。</p>
<p>假如你被逼的没办法手动或者写程序改完了这几十号头文件，那么你可以满怀期待的用我们上面提到的命令来打包了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod package YourPodName.podspec --force --library</span><br></pre></td></tr></table></figure>
<p>然而你又会收到另一条错误提示<code>[!] podspec has binary-only depedencies, mangling not possible.</code>，没错，Name-Mangling无法对静态库生效，我们只能暂时先选择不使用它:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod package YourPodName.podspec --force --library --no-mangle</span><br></pre></td></tr></table></figure>
<p>这下终于可以打包成功了！</p>
<p>但是...你会发现最终生成的静态库文件会包含我们引入的第三方静态库，即便你使用了<code>--exclude-deps</code>参数，它也只会去除我们引入的第三方开源库，静态库还是会被打包进去。那如果接入方也引入了这个第三方静态库，不还是会冲突？</p>
<p>What the f**k!!!</p>
<p>看来这条路是走不通了...</p>
<p>最终我们还是得回到Xcode上来...</p>
<h2 id="使用xcode打包静态库">使用Xcode打包静态库</h2>
<p>在我们的Demo project里面新增一个名为YourPodName的Library类型的Target，或者你重新建一个新的Library类型的项目，然后把我们pod库中的源文件都加进这个新的target，就像下面这样:</p>
<img src="/2019/03/13/sdk-development/target.png">
<p>修改一下<code>Build Settings</code>里的配置：</p>
<ol type="1">
<li><p>设置Supported Platforms为iOS</p></li>
<li><p>在Valid Architectures中添加<code>armv7</code>、<code>armv7s</code>、<code>arm64</code>、<code>arm64e</code>、<code>x86_64</code>等常用的架构</p></li>
<li><p>手动设置<code>Header Search Paths</code>和<code>Library Search Paths</code>以引入第三方静态库。</p></li>
</ol>
<p>不要忘记在Podfile当中新增下面的代码来让新的Target可以正常引入我们依赖的第三方开源库:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">'SmartPay'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'第三方开源库'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后执行<code>pod install</code>，你会发现CocoaPods在<code>Framework Search Paths</code>里面自动添加了类似<code>"/build/Debug/AFNetworking"</code>这样的路径，这个就是我们通过CocoaPods引入的第三方开源库最终编译成的framework的路径。</p>
<p>点击运行之后就会生成最终的静态库。这里生成的静态库是不会包含我们引入的第三方静态库和开源库的，所以在接入方接入我们的SDK的时候我们需要下面的这些东西:</p>
<ol type="1">
<li>SDK的静态库和头文件</li>
<li>引入的第三方静态库和头文件</li>
<li>CocoaPods生成的第三方开源库的.framework静态库（如果接入方项目中已经包含就不需要再引入了）</li>
<li>引入的系统framework名称列表</li>
</ol>
<h3 id="合并静态库文件">合并静态库文件</h3>
<p>我们可以在项目左侧Products文件夹下面亩看到一个名为libYourPodName的静态库文件。点击右键<code>Show in Finder</code>就可以在Finder中看到它。使用下面的命令可以查看它所包含的架构:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lipo -info 静态库路径</span><br></pre></td></tr></table></figure>
<p>如果你运行的时候选择的是模拟器，它就只包含x86_64架构，如果你选择的是Generic iOS Device，那么它会包含我们上面设置的arm架构。</p>
<p>对外我们可以把模拟器版和真机版的静态库分别输出或者使用下面的命令将他们合并成一个方便使用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lipo -create 静态库1路径 静态库2路径 -output 新静态库路径</span><br></pre></td></tr></table></figure>
<h3 id="接入sdk注意点">接入SDK注意点</h3>
<p>接入方接入我们的SDK就跟我们接入别人的静态库一样，除了需要在<code>Build Settings</code>中设置<code>Header Search Paths</code>和<code>Library Search Paths</code>以外还需要在<code>Build Phases</code>中的<code>Link Binary With Libraries</code>中添加我们SDK中引入的系统的framework。</p>
<p>然后把我们提供给他们的第三方开源库的静态framework拖入项目当中，这步操作就会把这些framework自动加入到<code>Build Phases</code>中的<code>Link Binary With Libraries</code>中去。这样还不够，因为这些第三方开源库是披着framework外衣的静态库，并不能像系统库那样动态链接。所以我们得在<code>General</code>中的<code>Embedded Binaries</code>中加入这些framework，这样他们就会像.a静态库一样内嵌到ipa当中去。</p>
<p>经过上面这些设置，项目已经可以正常运行了，但是在调用我们SDK中的分类方法时还是会报找不到Selector的错误，导致崩溃。</p>
<p>对于这个问题，只需要在<code>Build Settings</code>中的<code>Other Linker Flags</code>中添加<code>-ObjC</code>标志就可以了。</p>
<h3 id="objc标志的作用">-ObjC标志的作用</h3>
<p>Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现”selector not recognized”，也就是找不到方法定义的错误。为了解决这个问题，引入了-ObjC标志，它的作用就是让链接器将静态库中所有的Objective-C的代码都链接进来。</p>
<p>在64位的Mac系统或者iOS系统下，链接器有一个bug，会导致只包含有类别的静态库无法使用-ObjC标志来链接Objective-C代码。解决方法是使用-all_load 或者-force_load标志，它们的作用都是链接静态库中所有代码，不过all_load作用于所有的库，而-force_load后面必须要指定具体的文件。</p>

  </section>

</article>

<section class="read-more">
     
        

        
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2019/03/07/opengl-transform/" title="OpenGL学习笔记（三）：向量、矩阵和变换">OpenGL学习笔记（三）：向量、矩阵和变换</a></h2>
                <p class="excerpt">
                
                OpenGL学习笔记（一）：在Mac上编译GLFW并配置到Xcode项目
向量
向量最基本的定义就是一个方向。或者更正式的说，向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。如果一个向量有2个维度，它表示一个平面的方向，当它有3个维度的时候它可以表达一个3D世界的
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-03-07T03:38:21.000Z" class="post-list__meta--date date">2019/03/07</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/Graphic/">Graphic</a>

</span><a class="btn-border-small" href="/2019/03/07/opengl-transform/">继续阅读</a></div>

            </div>
        
   
</section>



<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'skx926'; // required: replace example with your forum shortname


      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>




            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2020 - 本站由 <a href="/">Kyle Sun</a> 创建,
        使用<a href="https://github.com/skx926/hexo-theme-vno">hexo-theme-vno</a>主题
    </span>
</footer>

        </div>
    </div>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="/js/main.js"></script>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-73055515-1', 'auto');
	ga('send', 'pageview');
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
